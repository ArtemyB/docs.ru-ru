---
title: "Обзор .NET"
description: "Обзор некоторых важных функций .NET."
keywords: ".NET, .NET Core, обзор, языки программирования, небезопасный, управление памятью, безопасность типа, асинхронный"
author: cartermp
ms.author: wiwagn
ms.date: 05/22/2017
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: bbfe6465-329d-4982-869d-472e7ef85d93
ms.openlocfilehash: 809f0eaddf298b0d6a57e217c2bcf5450675c3e9
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/18/2017
---
# <a name="tour-of-net"></a>Обзор .NET

.NET — это платформа разработки общего назначения. Она включает несколько основных функций (к примеру, поддержку нескольких языков программирования, модели асинхронного и параллельного программирования и взаимодействие на уровне машинного кода), благодаря которым на различных платформах доступно множество разнообразных сценариев.

В этой статье представлен обзор некоторых основных функций .NET. В разделе об [архитектурных компонентах .NET](components.md) вы сможете узнать о фрагментах архитектуры .NET и их целевом предназначении.

## <a name="how-to-run-the-code-samples"></a>Выполнение примеров кода

Сведения о том, как настроить среду разработки для выполнения примеров кода, представлены в разделе [о начале работы](get-started.md). Можно скопировать примеры кода с этой страницы и вставить их в вашу среду для выполнения. 

## <a name="programming-languages"></a>Языки программирования

Архитектура .NET поддерживает различные языки программирования. Реализации .NET реализуют [инфраструктуру CLI (Common Language Infrastructure)](https://www.visualstudio.com/license-terms/ecma-c-common-language-infrastructure-standards/), которая, среди прочего, указывает среду выполнения, не зависящую от языка, а также взаимодействие языков. Это означает, что для создания приложений и служб на платформе .NET можно выбрать любой язык .NET.

Корпорация Майкрософт активно занимается разработкой и поддержкой трех языков .NET: C#, F# и Visual Basic (VB). 

* C# — это простой, эффективный, типобезопасный и объектно-ориентированный язык, сохраняющий выразительность и элегантность, присущие языкам C. Все, кто знаком с C и схожими языками, могут без проблем перейти на C#. Чтобы узнать больше о языке C#, ознакомьтесь с [этим руководством](../csharp/index.md).

* F# — это кроссплатформенный и функционально-императивный язык программирования, который также поддерживает объектно-ориентированное и императивное программирование. Чтобы узнать больше о языке F#, ознакомьтесь с [этим руководством](../fsharp/index.md).

* Visual Basic — это простой язык, позволяющий научиться разрабатывать разнообразные приложения на .NET. Среди языков .NET синтаксис VB лучше всего соответствует обычному естественному языку, часто упрощая разработку для новичков.

## <a name="automatic-memory-management"></a>Автоматическое управление памятью

Архитектура .NET использует [сборку мусора](garbagecollection/index.md), чтобы обеспечить автоматическое управление памятью для программ. Сборка мусора отражает отложенный подход к управлению памятью, когда пропускная способность приложения предпочитается немедленной сборке памяти. Чтобы узнать больше о сборке мусора в .NET, см. статью [Fundamentals of garbage collection (GC)](garbagecollection/fundamentals.md) (Базовые понятия сборки мусора).

Обе приведенные ниже строки выделяют память:

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L1-L2)]

Аналогичных ключевых слов для отмены выделения памяти не существует, так как отмена осуществляется автоматически, когда сборщик мусора освобождает память в рамках запланированного выполнения.

Сборщик мусора — это одна из служб, которые помогают обеспечить *безопасность памяти*. Программа является безопасной по памяти, если она обращается только к выделенной памяти. Например, среда выполнения гарантирует, что приложение не обращается к невыделенной памяти за пределами границ массива.

В следующем примере среда выполнения порождает исключение `InvalidIndexException` для обеспечения безопасности памяти.

[!code-csharp[MemoryManagement](../../samples/csharp/snippets/tour/MemoryManagement.csx#L4-L5)]

## <a name="working-with-unmanaged-resources"></a>Работа с неуправляемыми ресурсами

Некоторые объекты ссылаются на *неуправляемые ресурсы*. Неуправляемые ресурсы — это ресурсы, которые не обслуживаются средой выполнения .NET автоматически. Например, к неуправляемым ресурсам относятся дескрипторы файлов. Объект <xref:System.IO.FileStream> — управляемый, но он ссылается на дескриптор файла, который является неуправляемым ресурсом. После окончания работы с <xref:System.IO.FileStream> нужно освободить дескриптор файла.

В среде .NET объекты, которые ссылаются на неуправляемые ресурсы, реализуют интерфейс <xref:System.IDisposable>. После окончания работы с объектом вызовите метод <xref:System.IDisposable.Dispose> объекта, который отвечает за освобождение неуправляемых ресурсов. В языках .NET для таких объектов есть удобный синтаксис `using`, как показано в следующем примере:

[!code-csharp[UnmanagedResources](../../samples/csharp/snippets/tour/UnmanagedResources.csx#L1-L6)]

После окончания блока `using` среда выполнения .NET автоматически вызывает метод <xref:System.IDisposable.Dispose> объекта `stream`, который освобождает дескриптор файла. Среда выполнения также делает это, если управление переходит за пределы блока из-за исключения.

Дополнительные сведения см в следующих разделах.

* Для C# — [Оператор using (Справочник по C#)](../csharp/language-reference/keywords/using-statement.md).
* Для F# — [Управление ресурсами: ключевое слово use](../fsharp/language-reference/resource-management-the-use-keyword.md).
* Для VB — [Оператор Using (Visual Basic)](../visual-basic/language-reference/statements/using-statement.md).

## <a name="type-safety"></a>Безопасность типа

Объект является экземпляром определенного типа. Разрешенные операции для заданного объекта определяются его типом. Тип `Dog` может иметь методы `Jump` и `WagTail`, но не метод `SumTotal`. Программа вызывает только методы, принадлежащие данному типу. Все другие вызовы приводят к ошибке во время компиляции или исключению во время выполнения (при использовании динамических функций или `object`).

Языки .NET являются объектно-ориентированными и имеют иерархии базовых и производных классов. Среда выполнения .NET допускает только те приведения и вызовы объектов, которые соответствуют иерархии объектов. Помните, что любой тип, определенный в любом языке .NET, является производным от базового типа <xref:System.Object>.

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L19-L23)]

Безопасность типа также используется для принудительной инкапсуляции, обеспечивая точность ключевых слов метода доступа. Ключевые слова метода доступа являются артефактами, которые управляют доступом к членам определенного типа из другого кода. Обычно они используются для различных видов данных внутри типа, которые позволяют управлять его поведением.

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L3-L3)]

Языки C#, Visual Basic и F# поддерживают *вывод локального типа*. Определение типа означает, что компилятор выводит тип выражения в левой части из выражения в правой части. Это не значит, что безопасность типа нарушается или исключается. Результирующий тип имеет строгий тип со всем, что подразумевается. В предыдущем примере `dog` и `cat` перезаписываются для представления вывода типа, а оставшаяся часть примера остается без изменений:

[!code-csharp[TypeSafety](../../samples/csharp/snippets/tour/TypeSafety.csx#L28-L34)]

В языке F# имеется даже больше возможностей вывода для типов, чем локальных выводов для типов методов в языках C# и VB. Для получения дополнительных сведений ознакомьтесь с разделом о [выводе типа](../fsharp/language-reference/type-inference.md).

## <a name="delegates-and-lambdas"></a>Делегаты и лямбда-выражения

Делегат представлен сигнатурой метода. Делегату можно назначить любой метод с этой сигнатурой и выполнить при вызове делегата.

Делегаты похожи на указатели функций в C++, но являются типобезопасными. Они представляют собой разновидность отключенного метода в системе типов CLR. Обычные методы присоединены к классу и вызываются только напрямую с помощью соглашений о статических вызовах или вызовах экземпляров.

В .NET делегаты обычно используются в обработчиках событий, при определении асинхронных операций и в лямбда-выражениях, которые являются основой LINQ. Дополнительные сведения см. в разделе [Делегаты и лямбда-выражения](delegates-lambdas.md).

## <a name="generics"></a>Универсальные шаблоны

Универсальные шаблоны позволяют программисту при разработке своих классов вводить *параметр типа*, который позволяет клиентскому коду (пользователям типа) указать точный тип, используемый вместо параметра типа.

Универсальные шаблоны были добавлены, чтобы помочь программистам реализовывать универсальные структуры данных. До их появления, чтобы тип `List` был универсальным, он должен был работать с элементами, имеющими тип `object`. Это бы вызвало различные проблемы, связанные с производительностью и семантикой, а также неочевидные ошибки во время выполнения. Наиболее печально известным вариантом последних является ситуация, когда структура данных содержит, например, как целые числа, так и строки, и при работе с элементами списка возникает исключение `InvalidCastException`.

В следующем примере показано выполнение простой программы с использованием экземпляра типов <xref:System.Collections.Generic.List%601>.

[!code-csharp[GenericsShort](../../samples/csharp/snippets/tour/GenericsShort.csx)]

Дополнительные сведения см. в разделе [Обзор универсальных типов (универсальных шаблонов)](generics.md).

## <a name="async-programming"></a>Асинхронное программирование

Асинхронное программирование является одной из ключевых концепций на платформе .NET, включающей асинхронную поддержку среды выполнения, библиотек платформы и языковых конструкций .NET. На внутреннем уровне это основано на объектах (таких как `Task`), которые используют возможности операционной системы для максимально эффективного выполнения заданий ввода-вывода.

Дополнительные сведения об асинхронном программировании в .NET см. в разделе [Обзор асинхронной модели](async.md).

## <a name="language-integrated-query-linq"></a>Синтаксис LINQ

LINQ — это эффективный набор функций для C# и VB, которые позволяют писать простой и декларативный код для работы с данными. Данные могут быть представлены разными формами (например, объектами в памяти, содержимым базы данных SQL или XML-документом), но обычно создаваемый код LINQ не отличается для каждого из источников данных.

Для получения дополнительных сведений и ознакомления с примерами см. раздел [Синтаксис LINQ](using-linq.md).

## <a name="native-interoperability"></a>Взаимодействие на уровне машинного кода

Все операционные системы имеют API-интерфейс, предоставляющий системные службы. .NET предоставляет несколько способов использовать эти API.

Основным способом осуществления такого взаимодействия является вызов неуправляемого кода или сокращенно P/Invoke, который поддерживается на платформах Linux и Windows. Способ, который подходит только для Windows, называется "COM-взаимодействием" и используется для работы с [COM-компонентами](https://msdn.microsoft.com/library/bwa2bx93.aspx) в управляемом коде. Он основан на инфраструктуре P/Invoke, но работает иначе.

Основная часть поддержки взаимодействия Mono (и, следовательно, Xamarin) для Java и Objective-C построена аналогичным образом, то есть использует схожие принципы.

Дополнительные сведения о взаимодействии на уровне машинного кода см. в документе [Взаимодействие на уровне машинного кода](native-interop.md).

## <a name="unsafe-code"></a>Небезопасный код

В зависимости от языковой поддержки среды CLR позволяет обращаться к внутренней памяти выполнять арифметические операции с указателями в коде `unsafe`. Эти операции необходимы для реализации определенных алгоритмов и системного взаимодействия. Хотя небезопасный код и предоставляет обширные возможности, использовать его не рекомендуется, если только это не требуется для взаимодействия с системными API или реализации максимально эффективного алгоритма. Небезопасный код может выполняться по-разному в разных средах, а также терять преимущества сборщика мусора и безопасности типов. Рекомендуется четко отделить и централизовать небезопасный код, а также тщательно протестировать его.

В следующем примере показана измененная версия метода `ToString()` из класса `StringBuilder`. Этот пример иллюстрирует, как с помощью кода `unsafe` можно эффективно реализовать алгоритм, перемещая блоки памяти напрямую:

[!code-csharp[Unsafe](../../samples/csharp/snippets/tour/Unsafe.csx)]

## <a name="next-steps"></a>Следующие шаги

Если вас интересуют возможности языка C#, ознакомьтесь с [соответствующим обзором](../csharp/tour-of-csharp/index.md).

Если вас интересуют возможности языка F#, ознакомьтесь с [соответствующим обзором](../fsharp/tour.md).

Если вы хотите приступить к написанию собственного кода, ознакомьтесь с [руководством по началу работы](get-started.md).

Дополнительные сведения о важных [компонентах архитектуры .NET](components.md).
